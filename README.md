# 数学関数がどのくらい「正しい値」から離れているかテストしてみた

C言語の規格では（たとえAnnex Fの下でも）sinやexpなどの超越関数の精度を規定していない。

世の中のlibm実装がどのぐらい「正しく丸められた値」から外れた値を返すのか調査してみた。

リファレンス実装（「正しく丸められた値」を得るための実装）としてはMPFRを使用した。

現在のところ、検証した関数はsinのみである。

## sin

x=2^n (-1000<=n<=1000) の形の入力に対してテストした。

### glibc (x86\_64, AArch64)

試した実装の中では（MPFRを除いて）最も優秀である。

x=`0x1p+25`, `0x1p+938`の2つを除いて正しく丸められた答えを返した。
「正しい丸め」と異なる結果を返した2つについても、差は1ulp以内だった。

### FreeBSD (x86\_64), Linux musl (x86\_64, AArch64)

試した範囲では、全ての入力に対して1ulp以内の答えを返した。

muslはFreeBSDの実装と全く同じ結果を返した。muslの数学関数はBSDベースだとどこかで読んだ気もする。

### macOS (x86\_64)

差が1ulpを超えるものも多くみられた。

### Windows mingw-w64 (x86\_64)

かなりずれている。

### Windows MSVS2019 (x86\_64)

試した範囲では、全ての入力に対して1ulp以内の答えを返した。
